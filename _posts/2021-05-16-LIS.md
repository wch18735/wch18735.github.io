---
title: "[Algorithm Problem] 가장 긴 증가하는 부분 수열"
excerpt: "가장 긴 증가하는 부분 수열 유형 정리"
date: 2021-05-16
layout: single
classes: wide
category:
    - algorithm problem
tag:
    - Python
    - C++
    - Dynamic Programming
    - Baekjoon
toc: true
toc_label: "Contents"
toc_icon: "heart"
author: 1FeS
comments: true
---

# Longest Increasing Subsequence (가장 긴 증가하는 부분 수열)

가장 긴 증가하는 부분 수열 문제는 동적 계획법을 이용해 푸는 대표적인 유형입니다. 이번 포스팅에서는 아래 문제들에 해당하는 개념들을 각각 다뤄볼 예정입니다.

- [백준 11053번: 가장 긴 증가하는 부분 수열1](https://www.acmicpc.net/problem/11053)
- [백준 12015번: 가장 긴 증가하는 부분 수열2](https://www.acmicpc.net/problem/12015)
- [백준 12738번: 가장 긴 증가하는 부분 수열3](https://www.acmicpc.net/problem/12738)
- [백준 14002번: 가장 긴 증가하는 부분 수열4](https://www.acmicpc.net/problem/14002)
- [백준 14003번: 가장 긴 증가하는 부분 수열5](https://www.acmicpc.net/problem/14003)

먼저 가장 긴 증가하는 부분 수열의 개념에 대해서 알아보겠습니다. 위의 문제들에서 대표적으로 활용되는 예시입니다. 수열 A = {10, 20, 10, 30, 20, 50} 가 주어질 때, **가장 긴 증가하는 부분 수열**는 아래와 같습니다.

<p style="text-align: center;">A = {<span style="font-weight:bold;">10</span>, <span style="font-weight:bold;">20</span>, 10, <span style="font-weight:bold;">30</span>, 20, <span style="font-weight:bold;">50</span>}</p>

우리는 가장 긴 증가하는 부분 수열의 길이를 구할 수 있고, 그 길이에 대응되는 수열을 출력할 수 있습니다. 이번 포스팅에서는 $O(N^2)$, $O(N \ logN)$ 의 시간복잡도로 문제를 푸는 방법을 정리하겠습니다.

## 수열의 길이를 구하는 유형

### $O(N^{2})$ 시간 복잡도

가장 긴 증가하는 부분 수열을 구성하는 원소를 구하기 전, 수열의 길이를 먼저 구해보겠습니다. 저는 위의 예시에서 가장 간단한 예부터 하나하나 증가시켜보며 **Cache 값**이 어떻게 변화하는 지를 확인하며 이해했습니다. 

먼저 Cache를 **DP[i]: i 번째까지 가장 긴 수열의 길이**로 정의합니다. 아래와 같이 시작은 **0번** 인덱스를 가리킵니다. 이를 **0**부터 추가하는 이유는 무엇일까요? 문제에서는 최소 길이가 1이지만 만약 아무 배열도 주어지지 않을 때, 가장 긴 증가하는 부분 수열의 길이를 0으로 출력하기 위함입니다.

![lis-1-1](/_img/2021-05-17/LIS_1-1.jpg){: .align-center}

**NOW**를 다음 칸으로 이동시킵니다. 그리고 아래의 과정을 거치며 **DP**를 업데이트 하겠습니다.

- **COMP**가 가리키는 값이 **NOW**가 가리키는 값보다 큰지 확인합니다.
    - **NOW**가 크다면 **DP[COMP] + 1** 값이 **DP[NOW]** 보다 큰지 확인합니다.
        - 더 크다면 **DP[NOW]** 값을 업데이트 합니다.
        - 작다면 순회를 계속합니다.
    - **COMP**를 한 칸 옆으로 이동합니다.
- **COMP**와 **NOW**가 같아지면 순회를 종료합니다.

**INDEX 1번** 칸에서는 **COMP**와의 비교가 한 번 일어납니다. 그리고 이때, **ARRAY[COMP]** 값이 0이고, **DP[NOW]** 값이 아직 아무것도 업데이트 되기 전이므로 이는 **DP[COMP] + 1**인 **1**이 됩니다.

![lis-1-1](/_img/2021-05-17/LIS_1-2.jpg){: .align-center}

이를 순서대로 진행하며 **배열이 최신화되는 과정**을 확인해보겠습니다. 아래 자료를 통해 각 **DP**가 어떻게 업데이트 되는지 눈으로 확인하면 조금 더 수월하게 이해할 수 있을 것 같습니다.

![lis-1-1](/_img/2021-05-17/lis_nsquare.gif){: .align-center}

**※ 추후 내용 추가**

