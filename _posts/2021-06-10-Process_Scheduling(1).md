---
title: "[OS] 프로세스 스케쥴링(1)"
excerpt: "process scheduling"
date: 2021-06-10
layout: single
classes: wide
category:
    - os
tag:
    - operating system
toc: true
toc_label: "Contents"
toc_icon: "heart"
author: 1FeS
comments: true
---

# Process scheduling

### Scheduler

|종류|특징|
|---|---|
|장기 스케줄러 (Long-term Scheduler)|어떤 프로세스가 시스템 자원을 차지할 것인가를 결정해 준비(Ready) 상태 큐로 보내는 작업<br>수행 빈도가 적고 느림|
|중기 스케줄러 (Mid-term Scheduler)|어떤 프로세스들이 CPU를 할당 받을 것인지 결정하는 작업<br>CPU 자원 할당을 대기하는 프로세스가 많을 경우, 프로세스를 일시 대기(Waiting)시킨 후 활성화해서 부하를 조절<br>메모리 부족 시 swap out, 메모리 여유 시 swap in 대상 프로세스 결정|
|단기 스케줄러 (Short-term Scheduler)|프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업<br>자주 수행되고 빠름|


이를 그림으로 표현하면 아래와 같습니다. 그림을 보면서 세부 설명을 읽으면 조금 더 이해가 쉬울 것 같습니다.

![process state diagram](/_img/2021-06-10/process_state.jpg){: .align-center}

**장기 스케쥴러(Long-term scheduler)** 는 어떤 프로세스를 **Ready Queue**에 넣을까를 결정하는 것입니다. 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데, 이때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지 결정하는 스케줄러입니다.

특정 프로그램 실행은 상대적으로 아주 가끔 실행되기 때문에 속도가 느린 것이 허용됩니다. 예를들어 Pycharm, Visual Studio 등의 IDE를 실행하는 것이 여기에 속합니다.

현대의 시분할 시스템에서 사용되는 운영체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분이라고 합니다. 이유는 과거보다 메모리 양이 크기 때문에 스케줄링을 거치지 않고 빈 메모리에 곧바로 할당할 수 있기 때문이라 합니다.

**중기 스케줄러(Mid-term scheduler)** 는 메모리에 적재된 프로세스 수를 관리합니다. 너무 많은 프로세스에게 메모리를 할당하면 프로세스 당 가지고 있는 메모리가 적어지게 됩니다. 이러한 경우 디스크 I/O가 수시로 발생하여 시스템의 성능이 저하될 수 있습니다. 이를 방지하기 위해 중기 스케줄러는 메모리에 적재된 프로세스들 중 일부를 Swap out 하여 디스크에 저장해 놓습니다.

가장 먼저 스왑 아웃되는 프로세스들은 Blocked 상태의 프로세스입니다. 이 경우에도 문제가 해결되지 않는다면 타이머 인터럽트가 발생해 Ready 상태로 이동한 프로세스를 추가적으로 스왑 아웃 시킵니다.

**단기 스케줄러(Short-term schduler)** 는 가장 빈번하게 발생하는 스케줄링입니다. 어떤 프로세스를 Running 상태로 만드는가를 결정합니다. 많은 알고리즘들이 있기 때문에 아래에서 자세히 다루겠습니다.

### Process Lifecycle

저는 단기 스케줄링을 곧 CPU 스케줄링으로 이해했습니다. 그렇다면 CPU 스케줄링은 언제 발생할까요? 

- 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 Block 상태가 되는 경우
- 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 되는 경우
- I/O 작업이 완료되어 인터럽트가 발생해 I/O 요청으로 Block 상태에 있던 프로세스가 준비 상태로 바뀌는 경우
- CPU에서 실행 상태에 있는 프로세스가 종료되는 경우

라고 요약할 수 있습니다. 위에서 파란색으로 표시된 동작들은 모두 단기 스케줄링이 발생하는 상황이라고 생각하시면 될 것 같습니다. 아래 그림은 프로세스 생명 주기를 보여주는 대표적이 그림입니다. 아래 나타난 상태 전환들에 모두 CPU Scheduling이 적용된다고 생각하면 될 것 같습니다.

![process lifecycle](/_img/2021-06-10/process_lifecycle.jpg){: .align-center}

### Non-Preemptive & Preemptive

비선점과 선점의 개념을 먼저 확인해보겠습니다. **선점형**은 현재 특정 주체가 소유하고 있는 자원을 다른 주체가 뺐어올 수 있다는 것입니다. 반대로 **비선점형**은 특정한 주체가 자원을 소유하고 있을 때 사용주체가 이를 놓아주기 전까지 그 어떤 개체도 자원을 뺏을 수 없다는 것입니다.

#### Non-Preemptive (비선점형)

비선점형 OS는 현재 실행 중인 프로세스보다 높은 우선순위를 가지는 프로세스가 실행되어도 CPU 실행 대상 프로세스를 변경하지 않습니다. 현재 실행 중인 프로세스가 명시적으로 CPU를 양보할 때까지 또는 I/O 작업 등으로 블로킹 상태가 될 때까지 기다려야 합니다.

과거 Windows95, Mac OS X 이전 운영체제들이 비선점형으로 동작했으며 이후에는 모두 선점형으로 동작합니다.

#### Preeptive (선점형)

선점형 OS는 실행 중인 프로세스보다 높은 우선순위를 가지는 프로세스가 실행되면 동작을 멈추고 더 높은 프로세스에게 자원을 할당합니다. 여기서 자원 할당이란 CPU 사용을 뜻합니다.

위에서 프로세스의 **Timer intterupt**가 발생하는 그림이 있습니다. **Deadlock**을 방지하기위해 현재 자원을 소유한 상태로 다른 자원을 대기하는 시간을 정해주어 이 시간이 지나면 Intterupt를 통해 자원을 반환하도록 설계했다고 생각했습니다.

관련된 내용은 후에 동기화와 Deadlock을 다루면서 조금 더 자세히 정리할 예정입니다.

### Reference
- [공대생의 개발PATH](https://kosaf04pyh.tistory.com/191)